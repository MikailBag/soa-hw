# Практика 3
Сервер реализован на Java и лежит в корне.
Клиент реализован на Go и лежит в `client/`.

## Комментарии по практике 3
Вместо условий вида "только мафия может писать в чат днем" и т.д., реализовано другое правило: у игровой комнаты есть
несколько стримов, каждый из которых является независимым чатом и имеет собственные проверки доступа. На мой взгляд,
такой подход более удобный (например, он не мешает игрокам общаться ночью, и при этом не усложняет координацию мафии).

Все сообщения пишутся в один топик. Возможна иная реализация, когда каждый стрим хранится в своем топике. Я не стал
к ней прибегать, так как она не дает профита в схеме с небольшим количеством инстансов сервера
(скорее всего, каждый все равно будет слушать все топики).

## Proto-файлы
Протокол взаимодействия - gRPC, интерфейсы описаны в `src/main/proto`.

Для простоты весь остальной код также манипулирует прото-сообщениями отдельные классы-модели как на клиенте, так и
на сервере отсутствуют.

Ручки API можно описать так:
- Создание/присоединение к комнате
- Получение состояния игры (если игра в процессе, то вся секретная информация маскируется)
- Наблюдение за игрой (реализовано не через server streaming, а через long polling)
- Выполнение игровых действий

## Устройство сервера
Исходный код сервера расположен в `src/main/java/com/example/demo`.
Он разделен на пакеты.

Пакет `repo` отвечает за хранение игр. В данной реализации состояние хранится в памяти, но остальной код
абстрагирован от этого. Можно взять любое достаточно умное хранилище (такое как MongoDB), реализовать поверх него
`GameRepository` и автоматически появится высокая доступность с надежностью. Этот же пакет схожим образом абстрагирует
работу с очередью сообщений.

Пакет `service` реализует ту часть игровой логики, которая четко привязана к пользовательским запросам.

Пакет `ctl` реализует оставшуюсю часть логики, которую удобнее применять реактивно. Для этого `ControllerRunner`
отслеживает все изменения игр и применяет к ним все контроллеры.

Наконец, пакет `api` реализует gRPC API. Остальной код от gRPC абстрагирован.

## Устройство клиента
Клиент также разделен на несколько пакетов.

Пакет `client` отвечает за подключение к серверу.

Пакет `pb` (генерируется скриптом `codegen.sh`) содержит сгенерированные служебные файлы.

Пакет `common` содержит вспомогательные для реализации клиента файлы.

Пакет `auto` реализует очень простую (самая умная часть - подбор имени) стратегии игры. Ручной режим не реализован.

Пакет `chat` прослушивает и выводит на экран все доступные боту сообщения в игровом чате.

## Запуск

Сборка образов: `bash push.sh` (если не закомментировать последние 2 строки, то команда сломается,
но ошибку можно игнорировать).
Скачивание готовых: `docker compose pull`
Запуск сервера: `docker compose up` (должно работать и без сборки).

Если не менять никаких настроек, то автоматически запустятся 4 клиента и сыграют в игру. При этом они поздороваются
друг с другом)